import numpy as np
from copy import deepcopy
import random
from Utilities import sigmoid
import operator
random.seed(0)
np.random.seed(0)

class particle:
    W=None
    wEND=0
    wSTART=1.0
    
    def __init__(self,particleid=0):
        self.particleID=particleid
        self.bestFitness=0
        self.pastPositions=[]
        self.currentPosition=None
        self.nextPosition=None
        self.bestPosition=None
        self.currentVelocity=None
        self.currentFitness=0
    
    def setNextPosition(self,newPosition):
        self.nextPosition=deepcopy(newPosition)
            
    def setCurrentPosition(self,newPosition):
        self.currentPosition=deepcopy(newPosition)
            
    def setBestPosition(self,newPosition):
        self.bestPosition=deepcopy(newPosition)
            
    def setBestFitnessScore(self,newScore):
        self.bestFitness=newScore
        
    def setCurrentFitnessScore(self,newScore):
        self.currentFitness=newScore
        
    def setW(self,C1,C2):
        self.wEND=((C1+C2)/2)-(1/(3.5/4))
        self.wSTART=1.0
        
    def printParticleInformation(self):
        print('Particle %s -- Best Fitness %s \n'%(str(self.particleID),str(self.bestFitness)))
            
    def standardVelocity(self,swarmBestPosition,mappingDict,T,C1,C2,maxIterations):
         particleBestPosition=deepcopy(self.bestPosition)
         particleCurrentPosition=deepcopy(self.currentPosition)
         swarmBestPosition=deepcopy(swarmBestPosition)
         self.calculateW(T,swarmBestPosition,maxIterations)
         v=[]
         alternatives=[]
         for i,x in enumerate(particleCurrentPosition):
             alternatives.append({})
             v.append({})
             if not x in mappingDict.keys():
                 alternatives[-1][x]=0
                 v[-1][x]=0
                 continue
             if particleBestPosition[i]==swarmBestPosition[i]==x:
                 alternatives[-1][x]=1
                 v[-1][x]=1
                 continue
             if (particleBestPosition[i] == swarmBestPosition[i]) and not (swarmBestPosition[i]==x):
                 alternatives[-1][particleBestPosition[i]]=1
                 v[-1][particleBestPosition[i]]=1
                 continue
             if particleBestPosition[i] in self.currentVelocity[i].keys():
                 pastV=self.currentVelocity[i][particleBestPosition[i]]
             else:
                 pastV=0
             alternatives[-1][particleBestPosition[i]]=(C2*np.random.uniform(0,1))+(pastV*self.W)
             if swarmBestPosition[i] in self.currentVelocity[i].keys():
                 pastV=self.currentVelocity[i][swarmBestPosition[i]]
             else:
                 pastV=0
             alternatives[-1][swarmBestPosition[i]]=(C1*np.random.uniform(0,1))+(pastV*self.W)
             for k in alternatives[-1].keys():
                 v[-1][k]=np.exp(alternatives[-1][k])/np.exp(sum([alternatives[-1][s] for s in alternatives[-1]]))
         self.currentVelocity=deepcopy(v)
         return v,alternatives
        
    def calculateNextPosition(self,swarmBestPosition,T,mappingDict,C1,C2,maxIterations):
        v,_=self.standardVelocity(swarmBestPosition,mappingDict,T,C1,C2,maxIterations)  
        nextPosition=deepcopy(self.currentPosition)
        changes=0
        for i,_ in enumerate(nextPosition):
            highestProb=max(v[i].items(),key=operator.itemgetter(1))
            if ((nextPosition[i]==0) or (not nextPosition[i] in mappingDict.keys())):             
                continue
            elif highestProb[1] > np.random.uniform(0.0,1.0):# and len(alternatives[i])>0:
#                if not highestProb[0] in [mappingDict[nextPosition[i]][keys] for keys in mappingDict[nextPosition[i]]]:
#                    print(False)
                nextPosition[i]=highestProb[0]
                changes=changes+1
        if len(nextPosition) < len(swarmBestPosition):
            temp=[0]*(len(swarmBestPosition)-len(nextPosition))
            temp.extend(nextPosition)
            nextPosition=temp
        self.setCurrentPosition(nextPosition)
        return nextPosition,changes
        
    def calculateW(self,T,swarmBestPosition,maxIterations):
        if np.all(np.equal(self.bestPosition,swarmBestPosition)):
            W=self.wEND
            self.W=W
            return self.W
        elif not np.all(np.equal(self.bestPosition , swarmBestPosition)):
            W=self.wEND+((self.wSTART-self.wEND)*(1-(T/maxIterations)))
            self.W=W
            return self.W
            
    def randomMutation(self,searchSpace,mappingDict):
        flag=False
        for i in searchSpace:
            flag=True
            alternatives=[mappingDict[self.currentPosition[i]][keys] for keys in mappingDict[self.currentPosition[i]].keys() if 'name' not in keys]
            self.currentPosition[i]=random.choice(alternatives)
        self.setNextPosition(self.currentPosition)
        return flag