from particle import particle
from Utilities import list_rindex,fitnessScore
import numpy as np
from copy import deepcopy
import random
from Mappings import Mappings
from Dataset import loadSurrogate
from keras.preprocessing import sequence
import operator
random.seed(0)
np.random.seed(0)

class Swarm:
    numberOfChanges=0
    
    def __init__(self,numOfParticles,dLength,stoppingThreshold,randomMutation,maxQueries,x,C1,C2):
        self.numberOfParticles=numOfParticles
        self.targetModel=loadSurrogate()
        self.bestFitness=0
        self.numberOfQueries=0
        self.bestPosition=[1]*dLength
        self.dLength=dLength
        self.stoppingThreshold=stoppingThreshold
        self.randomMutation=randomMutation
        self.maxQueries=maxQueries
        self.mappings=Mappings()
        self.inputX=x
        self.inputX=self.mappings.Custom_Embedding([self.inputX])
        self.inputX=sequence.pad_sequences(self.inputX, maxlen=dLength,padding='pre')[0]
        self.bestProba=[]
        self.setCs(C1,C2)
        
    def setBestPosition(self,newPosition):
        self.bestPosition=deepcopy(newPosition)
            
    def setCs(self,C1,C2):       
        self.C1=C1
        self.C2=C2
        
    def setBestFitnessScore(self,newScore):
        self.bestFitness=newScore
        
    def incrementChanges(self):
        self.numberOfChanges=self.numberOfChanges+1
 
    def calculateBaselineConfidence(self):
        pred=self.targetModel.predict_proba(np.asarray([self.inputX]))
        proba=pred[0][0]
        self.baselineConfidence=deepcopy(proba)
        return proba,pred
        
    def generateSearchSpace(self):
        if 0 in self.inputX:
            lastZeroIndex=list_rindex(self.inputX,0)
            searchSpace=range(lastZeroIndex+1,self.dLength) 
        else:
            searchSpace=range(0,self.dLength)
        self.searchSpace=list([a for a in searchSpace if self.inputX[a] in self.mappings.apiMappingsDict.keys()])
        random.shuffle(self.searchSpace)

    def initializeSwarmAndParticles(self):
        print('Initializing Swarm and Particles..\n')
        self.initializeSwarm()
        self.initializeParticles()
        
    def initializeSwarm(self):
        self.generateSearchSpace()
        self.changeRate=int(np.ceil(len(self.searchSpace)/self.numberOfParticles))   
        self.setBestPosition(self.inputX)
        self.setBestFitnessScore(0) 
        
    def initializeParticles(self):
        particleList=[]        
        for x in range(self.numberOfParticles):
            p=None
            p=particle(x)
            p.setW(self.C1,self.C2)
            p.currentVelocity=[]
            for i,x in enumerate(self.inputX):
                if x in self.mappings.apiMappingsDict.keys():
                    p.currentVelocity.append({self.mappings.apiMappingsDict[x][m]:np.random.uniform(0.0,1.0) for m in self.mappings.apiMappingsDict[x].keys() if not m=='name'})
                else:
                    p.currentVelocity.append({x:0})
            p.setBestFitnessScore(self.bestFitness)
            p.setBestPosition(self.bestPosition)
            self.randomizeParticle(p,self.inputX)
            particleList.append(deepcopy(p))
        self.particles=deepcopy(particleList)
            
    def randomizeParticle(self,p,basePosition):
        temp=deepcopy(basePosition)
        for i,x in enumerate(temp):
            if x in self.mappings.apiMappingsDict.keys():
                highestProb=max(p.currentVelocity[i].items(),key=operator.itemgetter(1))
                if highestProb[1]>np.random.uniform(0.0,1.0):
                    self.incrementChanges()
                    temp[i]=highestProb[0]
        p.setCurrentPosition(temp)
        self.check(p)
        p.pastPositions.append(p.currentPosition)     

    def generateRandomSearchSpace(self):
        if len(self.searchSpace)<self.changeRate:
            self.generateSearchSpace()
        indices=random.sample(self.searchSpace,self.changeRate if self.changeRate<=len(self.searchSpace) else len(self.searchSpace))
        self.searchSpace=[i for i in self.searchSpace if not i in indices]
        return indices
        
    def searchOptimum(self,sampleNumber=None):
        if self.bestFitness > self.stoppingThreshold:
            return self.bestPosition , self.bestFitness,0,self.numberOfQueries
        iteration=1
        while self.numberOfQueries<self.maxQueries:
            if self.bestFitness > self.stoppingThreshold:
                return self.bestPosition , self.bestFitness,iteration,self.numberOfQueries
            for p in self.particles:
                indices=self.generateRandomSearchSpace()
                flag=p.randomMutation(indices,self.mappings.apiMappingsDict)
                if flag:
                    self.check(p)
                _,changes=p.calculateNextPosition(self.bestPosition,self.numberOfQueries,self.mappings.apiMappingsDict,self.C1,self.C2,self.maxQueries)   
                self.numberOfChanges=self.numberOfChanges+changes
                self.check(p)
            if len(self.bestProba)>0 and np.argmax(self.bestProba)==0:
                return deepcopy(self.bestPosition) , self.bestFitness, iteration ,self.numberOfQueries
            print('Iteration %s - Best Fitness %s - Number of Queries %s'%(str(iteration),str(self.bestFitness),str(self.numberOfQueries)))
            iteration=iteration+1
        print("Number of Queries: %s"%(self.numberOfQueries))
        return deepcopy(self.bestPosition) , self.bestFitness, iteration ,self.numberOfQueries       

    def check(self,p):
        newFitness,newProba=fitnessScore(p.currentPosition,self.targetModel,self.baselineConfidence)
        self.numberOfQueries=self.numberOfQueries+1
        p.setCurrentFitnessScore(newFitness)
        if newFitness > p.bestFitness:
            p.setBestFitnessScore(newFitness)
            p.setBestPosition(p.currentPosition)
        if p.bestFitness > self.bestFitness:
            self.setBestFitnessScore(p.bestFitness)
            self.setBestPosition(p.bestPosition)
            self.bestProba=deepcopy(newProba)
                
        
